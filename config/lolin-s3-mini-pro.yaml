esphome:
  name: lolin-s3-mini-pro
  libraries:
    - "Wire"
    - "SPI"
    # - "SensorLib"
    - "SensorLib@0.2.1"  # Some change after v0.2.1 makes compiling fail
  on_boot:
    then:
      # Turn on backlight and power to neopixel
      -   output.turn_on: backlight_output
      -   output.turn_on: neopixel_power


external_components:
    -   source: github://dala318/esphome-qmi8658

# Example configuration entry
esp32:
  board: esp32-s3-devkitc-1
#  board: lolin32
  variant: esp32s3
  framework:
    type: arduino
  #framework:
   # type: esp-idf



# Enable logging for debugging
logger:

# Enable the Home Assistant API
api:

# Enable over-the-air updates
ota:
  - platform: esphome

wifi:
    ssid: !secret wifi_ssid
    password: !secret wifi_pw
    fast_connect: on

## I2C bus for the IMU sensor
#i2c:
#  sda: GPIO35
#  scl: GPIO36
#
#
## QMI8658C 6-axis IMU sensor
#sensor:
#  - platform: qmi8658
#    address: 0x6B
#    acceleration_x:
#      name: "IMU Accelerometer X"
#    acceleration_y:
#      name: "IMU Accelerometer Y"
#    acceleration_z:
#      name: "IMU Accelerometer Z"
#    gyroscope_x:
#      name: "IMU Gyroscope X"
#    gyroscope_y:
#      name: "IMU Gyroscope Y"
#    gyroscope_z:
#      name: "IMU Gyroscope Z"
#    temperature:
#      name: "QMI8658 Temperature"
#      filters:
#        - offset: 34.0
#    update_interval: 5s

# WS2812 LED
# PIN GPIO07 needs to be HIGH so it gets power
light:
  - platform: esp32_rmt_led_strip
    rgb_order: RGB
    id: neopixel
    pin: GPIO08
    num_leds: 1
    rmt_channel: 0
    chipset: ws2812
    name: "Neopixel"

# Backlight and WS2812 Power Supply
output:
  - platform: gpio
    pin: GPIO07
    id: neopixel_power
  - platform: gpio
    pin: GPIO33
    id: backlight_output

# Buttons
binary_sensor:

  - platform: gpio
    name: "Button - Left"
    pin:
      number: GPIO0
      inverted: true
      mode:
          input: true
          pullup: true
    on_press:
      then:
        - light.turn_on:
            id: neopixel
            red: 1
            green: 0
            blue: 0
        - lambda: !lambda |-
            // Check if the active screen is the select page
            if (lv_disp_get_scr_act(NULL) == id(select_page)->obj) {
              // Pass the raw object pointer to the LVGL function
              lv_roller_set_selected(id(roller_id)->obj, lv_roller_get_selected(id(roller_id)->obj) - 1, LV_ANIM_ON);
            }
        - lvgl.update:
              disp_bg_color: 0x0000FF

  - platform: gpio
    name: "Button - Middle"
    pin:
      number: GPIO47
      inverted: true
      mode:
          input: true
          pullup: true
    on_press:
      then:
        - light.turn_on:
            id: neopixel
            red: 0
            green: 1
            blue: 0
        - lambda: !lambda |-
            if (lv_disp_get_scr_act(NULL) == id(main_page)->obj) {
              // If we are currently on the main page, load the select page.
              lv_scr_load(id(select_page)->obj);
            } else {
              // Otherwise, we must be on the select page, so load the main page.
              lv_scr_load(id(main_page)->obj);
            }
        - lvgl.update:
              disp_bg_color: 0x0000FF

  - platform: gpio
    name: "Button - Right"
    pin:
      number: GPIO48
      inverted: true
      mode:
          input: true
          pullup: true
    on_press:
      then:
        - light.turn_on:
            id: neopixel
            red: 0
            green: 0
            blue: 1
        - lambda: !lambda |-
            // Check if the active screen is the select page
            if (lv_disp_get_scr_act(NULL) == id(select_page)->obj) {
              // Pass the raw object pointer to the LVGL function
              lv_roller_set_selected(id(roller_id)->obj, lv_roller_get_selected(id(roller_id)->obj) + 1, LV_ANIM_ON);
            }
        # 2. Then, tell LVGL to redraw the screen
        - lvgl.update:
              disp_bg_color: 0x0000FF


# Infrared transmitter
#remote_transmitter:
#  pin: GPIO9
#  carrier_duty_percent: 50%

spi:
  clk_pin: GPIO40
  mosi_pin: GPIO38

display:
  - platform: ili9xxx
    id: disp
    dimensions:
      height: 128
      width: 128
      offset_height: 1
      offset_width: 2
    model: st7789v
    data_rate: 80MHz
    cs_pin: GPIO35
    dc_pin: GPIO36
    reset_pin: GPIO34
    invert_colors: true
    transform:
      mirror_x: true
      mirror_y: true


lvgl:
    log_level: INFO
    color_depth: 16
    bg_color: 0
    border_width: 0
    outline_width: 0
    text_font: unscii_16
    align: center
    style_definitions:
      - id: font_style
        text_font: MONTSERRAT_12
        align: center
        text_color: 0xFFFFFF
        bg_opa: TRANSP
        bg_color: 0
        radius: 4
        pad_all: 2
      - id: details_style
        text_font: MONTSERRAT_16
        align: center
        text_color: 0xFFFFFF
        bg_opa: TRANSP
        bg_color: 0
        radius: 4
        pad_all: 2
    page_wrap: true
    pages:
        - id: main_page
          widgets:
            - obj: # Container
                height: 128
                width: 128
                align: center
                bg_color: 0
                border_width: 0
                outline_width: 0
                pad_all: 0
                scrollbar_mode: "off"
                widgets:
                  - label:
                      styles: details_style
                      id: label_current_mode
                      align: center
                      text: "Loading..." # Changed initial text

        # --- THIS IS THE SECOND PAGE ---
        - id: select_page
          widgets:
            - roller:
                  align: CENTER
                  id: roller_id
                  mode: INFINITE
                  options:
                      - "off"
                      - "pv"
                      - "minpv"
                      - "now"

font:
  - file: "gfonts://Roboto"
    id: my_font
    size: 24

# LVGL Select - binds directly to the roller widget
select:
  - platform: lvgl
    widget: roller_id
    name: "EVCC Mode Select"
    id: evcc_mode_select
    on_value:
      then:
        # 1. Send the new value to Home Assistant
        - homeassistant.service:
            service: select.select_option
            data:
              entity_id: select.evcc_warp_3_mode
              # 'x' contains the selected option text (e.g., "pv")
              option: !lambda 'return x;'
        # 2. Also update the label on your main page immediately
        - lambda: !lambda |-
            lv_label_set_text(id(label_current_mode), x.c_str());

# Text sensor for Home Assistant integration
text_sensor:
  - platform: homeassistant
    entity_id: select.evcc_warp_3_mode
    id: ha_evcc_mode_text
    on_value:
      then:
        # Update the LVGL select and main page label when Home Assistant changes
        - select.set:
            id: evcc_mode_select
            option: !lambda "return x;"
        # Update the current mode display on main page
        - lambda: !lambda |-
            lv_label_set_text(id(label_current_mode), x.c_str());


## Automation to sync changes from LVGL select back to Home Assistant
## When the roller changes, update Home Assistant
#automation:
#  - trigger:
#      - platform: state
#        entity_id: select.evcc_mode_select  # This is the LVGL select
#    action:
#      - homeassistant.service:
#          service: select.select_option
#          data:
#            entity_id: select.evcc_warp_3_mode
#            option: "{{ trigger.to_state.state }}"
